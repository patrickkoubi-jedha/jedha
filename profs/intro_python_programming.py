# -*- coding: utf-8 -*-
"""Intro-python-programming.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tpDMlfP8MnB8wCnGIz6ntp495uz4FNnm

# Introduction Python : operations de base

## Utiliser python comme une calculatrice
"""

# Addition
1+1

# Multiplication

3*2

# Division

9/2

# Division euclidienne (division avec reste)
print(f"quotient de la division {9//2}")
print(f"reste de la division {9%2}")

# Puissance

3**2

"""## Les variables"""

a = 3
a += 1 # Il existe aussi le  /= le *= ...
print(a)

variable_1 = 10
variable_2 = variable_1
variable_2 += 3
print(f"La variable_1 vaut : {variable_1} et la variable_2 vaut : {variable_2}")

"""### Interactivité avec l'utilisateur : input"""

variable_a_entrer = input("Veuillez entrer une variable")

print(variable_a_entrer)

### Attention : par défaut cela créé un string

variable_a_entrer = input("Veuillez entrer une variable")

variable_convertie_en_int = float(variable_a_entrer)
print(variable_convertie_en_int + 2)

input1 = int(input("mettez un entier"))
input2 = float(input("mettez un nombre decimal"))

print(input1 + input2)

"""## Le bloc if

```
if condition:
    code
else:
    code
```
"""

a = 9
if a%2 == 0:
  print(f"a est pair : {a}")
else:
  print(f"a est impair : {a}")

# Le else n'est pas obligatoire

a = 9
if a%2 == 0:
  print(f"a est pair : {a}")
b = a
print(b+1)

"""### Le else + if : elif

```
if first_condition:
    Code
elif second_condition:
    Code
else:
    code
```
"""

# Un script qui va afficher ma variable si elle est paire ou inférieure à 10
variable_test = 12
if variable_test % 2 == 0:
  print(variable_test)
elif variable_test < 10:
  print(variable_test)
else:
  print("la variable n'est ni paire, ni inferieure à 10")

"""Les différents opérateurs de tests sont :    
- > ou >=
- < ou <=
- == ou !=
- and ou or
"""

# Un script qui va afficher ma variable si elle est paire ou inférieure à 10

variable_test = 5
if (variable_test % 2 == 0) or (variable_test < 10):
  print(variable_test)
else:
  print("la variable n'est ni paire, ni inferieure à 10")

"""## La boucle for

```
for item in iterator:
    code
```


Un façon simple de faire un itérateur : le range

```
for i in range(start,stop,step):
    code
```

- on commence **pile au start**
- on avance de step
- on s'arrete **juste avant d'arriver au stop**
"""

for i in range(3,8,2): # On commence pile
    print(i)

for i in range(3,9,2):
    print(i)

# Par défaut le step vaut 1,  et il est la variable assignée si nne précise que 2 variables (start, stop)

for i in range(3,5):
    print(i)

print("____________________________________")
# Par défaut le start vaut 0, et il est assigné si on n'en précise que 1 variable (stop)
for i in range(3):
  print(i)

# Bonus : s'il n'y a rien dans le range, il ne fait rien
for i in range(5,3,1):
  print(i)

# Bonus : on peut avoir un step négatif (décrément)
for i in range(5,3,-1):
  print(i)

# Attention : on ne peut pas mettre de float (décimales) dans le range
for i in range(1,2,0.2):
  print(i)

"""### Apparte sur les listes
```
liste= [1,3,5,12,1,9.6]
```
une liste c'est :    
- un objet informatique qui permet de stocker d'autres objets
- elle commence par [ et finit par ]
- les objets stockés sont séparés par une ,
"""

liste= [1,3,5,12,1,9.6]
for element in liste:
  print(element)

"""## boucle while

```
while condition:
    code
```
"""

variable_stop = 2

while variable_stop < 6:
  print(variable_stop)
  variable_stop += 1

# Attention : while peut mener à bug de "boucle infinie"

variable_stop = 7

while variable_stop > 6:
  variable_stop += 1

"""## Instructions break et continue

"""

# Le break "casse" une (la dernière) boucle et en fait sortir

for i in range(5):
  print(i)
  if i >= 3:
    break

# Le continue permet de passer directement à la prochaine iteration de la derniere boucle (sans executer la fin du bloc de code de la boucle en cours)

for i in range(5):
  if i == 3:
    print("je rentre dans le continue")
    continue
  print(i)

"""# Data types : listes, dictionnaires, tuple

## Les listes

```
liste= [1,3,5,12,1,9.6]
```
une liste c'est :    
- un objet informatique qui permet de stocker d'autres objets
- elle commence par [ et finit par ]
- les objets stockés sont séparés par une ,

```
liste2= [1,12,1,9.6,"bonjour",[1,2,1],liste]
```
"""

liste= [1,3,5,12,1,9.6]
liste2= [1,12,1,9.6,"bonjour",[1,2,1],liste]

print(f"liste = {liste}")
print(f"liste2 = {liste2}")

# Pour récupérer un élément d'une liste, je le référence par son index (sa position dans la liste)
# EN PYTHON ON COMMENCE A COMPTER A PARTIR DE 0

print(liste[0]) # premier element de liste
print(liste2[1]) # DEUXIEME element de liste2

# On peut mettre un indice négatif : on commence à compter à partir de la fin
# ATTENTION : quand on commence à compter à partir de la fin, on commence à compter à partir de -1

liste= [1,3,5,12,1,9.6]
liste2= [1,12,1,9.6,"bonjour",[1,2,1],liste]

print(liste[-1]) # premier element de liste
print(liste2[-2]) # DEUXIEME element de liste2

"""### Les slices
```
liste[start:stop]
```

"""

liste= [1,3,5,12,1,9.6]

print(liste[2:4]) # On commence PILE au start et on s'arrete JUSTE AVANT stop

# Par défaut le start vaut 0
print(liste[:4])

# Par défaut le stop s'arrete a la fin de la liste
print(liste[4:])

print(liste[:])

"""### Changer les elements d'une liste"""

# Changer un seul element

list_1 = [1, 2, 3, 4, 5]

print(list_1)
list_1[3] = 99999
print(list_1)

# Ajouter des  element a une liste

# Methode 1 : le + entre listes

list_1 = [1, 2, 3, 4, 5]
list_2 = [3,2,5]
list_3 = list_1 + list_2
print(list_3)

## Ajout d'un seul element
list_1 = [1,2]
a = 3
list_1 = list_1 + [a]
# pareil que list_1 += [a]
print(list_1)

# Methode 2 pour ajout d'UN SEUL element
list_2 = [1, 2, 3, 4, 5]
add_2 = 'test' # with append, we don't need brackets anymore "[]"

list_2.append(add_2)
print(list_2)

# Attention, le append ne marche pas pour plusieurs elements

list_2 = [1, 2, 3, 4, 5]
add_2 = 'test' # with append, we don't need brackets anymore "[]"

list_2.append(add_2,3,1,14)
print(list_2)

# Attention, le append ne marche pas pour plusieurs elements

list_2 = [1, 2, 3, 4, 5]
add_2 = 'test' # with append, we don't need brackets anymore "[]"

list_2.append([add_2,3,1,14])
print(list_2)

# Methode 3 pour ajout de PLUSIEURS elements

list_4 = [1, 2, 3, 4, 5]
add_4 = ['test1', 'test2', 'test3']
list_4.extend(add_4)
print(list_4)

"""### Supprimer des elements d'une liste


"""

# Supprimer par l'indice

list_1 = [1, 2, 4]
del(list_1[1])
print(list_1)

# Supprimer par la valeur

# remove item with the .remove method
list_1 = [1, 2, 4]
list_1.remove(1)
print(list_1)

# Supprimer par la valeur

# remove item with the .remove method
list_1 = [1, 2, 4,1,14]
list_1.remove(1)
print(list_1)

### Bonus : supprimer toutes les occurrences : remove + while

list_2 = [1, 2, 'to_remove', 4, 'to_remove', 'to_remove']

while 'to_remove' in list_2:
    list_2.remove('to_remove')
print(list_2)

# Methode 3 : supprimer une valeur et la recuperer (c'est un peu un del mais qui permet de recuperer la valeur)
list_1 = [1, 2, 4]
elem = list_1.pop(1)
print(elem)
print(list_1)

# Par defaut le .pop recupere le dernier element de la liste
list_1 = [1, 2, 4]
elem = list_1.pop()
print(elem)
print(list_1)

"""### Comprehension de liste"""

liste = []
for i in range(1,11):
  liste += [i]
print(liste)

# Je fais une comprehension de liste
liste = [i for i in range(1,11)]
print(liste)

# Plus poussé
liste = [2*i/i**2 for i in range(1,11)]
print(liste)

# Plus poussé : on peut ajouter un filtre
liste = [i for i in range(1,11) if i%2 == 0]
print(liste)

# assez poussé : on peut ajouter un if + else
liste = [i if i%2 == 0 else "chiffre impair" for i in range(1,11)]
print(liste)

# fait exactement pareil que
liste_exemple2 = []
for i in range(1,11):
  if i % 2 == 0:
    liste_exemple2 += [i]
  else:
    liste_exemple2 += ["chiffre impair"]
print(liste_exemple2)

"""## Les dictionnaires

### Créer / Instancier un dictionnaire

C'est une structure de donnée, qui permet de stocker des informations (comme la liste).
Cependant au lieu de les stocker sous un certain "ordre" (premier element, deuxieme element....), on les stock sous une CLE (tuple, chaine de caractere, int). Tres souvent c'est une chaine de caractere

```
dictionnaire = {cle1: element1, cle2: element2, ...}
```
Exemple 1:
```
dic1 = {'first_name': 'Antoine', 'last_name':'Dupont'}
```
Exemple 2:
```
dic1 = {0: 'Antoine', 12:'Dupont'}
```
Exemple 3:
```
dic1 = {"cle1": ['Antoine','12'], 12:['Dupont',[12]]}
```
Exemple 4:
```
dic1 = {0: 'Antoine', 12:'Dupont}
```
"""

dic1 = {'first_name': 'Antoine', 'last_name':'Dupont'}
dic1 = {0: 'Antoine', 12:'Dupont'}
dic1 = {"cle1": ['Antoine','12'], 12:['Dupont',[12]]}
dic1 = {0: 'Antoine', 12:'Dupont'}

"""### Modifier un dictionnaire"""

dic1 = { # Bonus : quand on voutre (, [ ,{ , Python considère qu'on est sur la meme ligne jusquà ce que ce ), ], } soit fermé
    'first_name': 'Antoine',
    'last_name':"Dupont"
       }


# Modifier un element
dic1["first_name"] = "Arthur"

print("dic1",dic1)


#Modifier un element 2 : cas particulier liste
dic2 = {'liste_de_valeurs':[1,4,21]}

# Methode 1 : direct (on reparlera de cette technique en fin de notebook dans la section ## Copie de listes
dic2['liste_de_valeurs'][1] = 9999

# Methode 2 : on "colle" a la technique de base
liste = dic2['liste_de_valeurs']
liste[1] = 999999
dic2["liste_de_valeurs"] = liste

# Modifier un element 3
dic3 = {'liste_de_valeurs':[1,4,21]}
dic3['liste_de_valeurs'].append("Antoine")
print(dic3)

# Methode 2 : dic3['liste_de_valeurs'] = dic3['liste_de_valeurs'] + ['Antoine]

# Ajouter un element sous une cle
dic = {'first_name': 'Antoine'}
dic["age"]=30
print(dic)

# Supprimer une cle + valeur

dic1 = {'first_name': 'Antoine','last_name':"Dupont"}

del(dic1["first_name"])
print(dic1)

"""###  Boucler sur des dictionnaires

```for it in iterator```

On peut boucler sur un dictionnaires, en récupérant :    
- la "liste" des clés : dict.keys()
- la "liste" des valeurs : dict.values()
"""

# Boucler sur les clés :
dic1 = {'first_name': 'Antoine','last_name':"Dupont"}
for key in dic1.keys():
  print(f"ma cle vaut {key}")
  print(f"ma valeur vaut {dic1[key]}")
  print("_____________________________")

# Boucler sur les valeurs :
dic1 = {'first_name': 'Antoine','last_name':"Dupont"}
for val in dic1.values():
  print(f"ma valeur vaut {val}")
  print("_____________________________")

# Bonus : on peut boucler sur cle + valeur en meme temps

dic1 = {'first_name': 'Antoine','last_name':"Dupont"}
for key,value in dic1.items():
  print(key,value)
  print("___________________________")

"""### Les tuples

C'est une liste, sauf que :    
- on utilise pas des [] mais des ()
- c'est un type immutable : quand on le créé, on ne peut PLUS changer ses elements
"""

tple = (1,3,12,14,2)
print(tple)

tple[2]

tple[:2]

# Seule difference : je ne peux pas changer les elements

tple[1] = 99999

""" ## Bonus : copies de listes"""

# Quand on manipule une copie de varialbe

variable_1 = 10
variable_2 = variable_1
variable_2 += 3
print(f"La variable_1 vaut : {variable_1} et la variable_2 vaut : {variable_2}")

# ATTENTION: Quand on manipule une copie de liste
# Si vous modifiez la SHALLOW COPIE (copie de surface) alors ca modifie l'ORIGINAL

liste1 = [10,12,41,1]
liste2 = liste1
liste2[0] = 99999999
print(f"La liste1 vaut : {liste1} et la liste2 vaut : {liste2}")

# ATTENTION: Quand on manipule une copie de liste
# Si vous voulez modifier la copie sans modifier l'originale, faire une DEEP COPY
# Methode 1
liste1 = [10,12,41,1]
liste2 = liste1[:]
liste2[0] = 99999999
print(f"La liste1 vaut : {liste1} et la liste2 vaut : {liste2}")

# ATTENTION: Quand on manipule une copie de liste
# Si vous voulez modifier la copie sans modifier l'originale, faire une DEEP COPY
# Methode 2
liste1 = [10,12,41,1]
liste2 = liste1.copy()
liste2[0] = 99999999
print(f"La liste1 vaut : {liste1} et la liste2 vaut : {liste2}")

"""## Ensembles

Un ensemble c'est une structure :    
- pas d'ordre
- pas de doublon
"""

ens = {1,3,21}
ens

ens = {1,3,21,1,3}
ens

liste = [1,31,41,1,21,1,31,55,32]
ens = set(liste)
ens