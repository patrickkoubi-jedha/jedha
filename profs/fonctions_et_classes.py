# -*- coding: utf-8 -*-
"""Fonctions et classes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nElpdCH82feRVV8GeoUVNi0nIPwM95yC

## Fonctions

### Definir une fonction

```
def name_of_the_function(arguments):
    instructions
    return result # optional: allows to reuse the result of a calculation

outside the function
```
"""

# Exemple : Je veux calculer l'énergie totale d'un objet :
# on a l'énergie cinétique E_c = 1/2 * m * v**2
# on a l'énergie potentielle E_p = m * g * h
# l'energie totale = E_c + E_p

masse_objet1 = 12
vitesse_objet1 = 10
hauteur1 = 10
E_c_objet1 = 1/2 * masse_objet1 * vitesse_objet1**2
E_p_objet1 = masse_objet1 * 9.8 * hauteur1
print(f"energie totale objet 1 = {E_c_objet1 + E_p_objet1}")

# On a un deuxieme objet
masse_objet2 = 100
vitesse_objet2 = 0
hauteur2 = 100
E_c_objet2 = 1/2 * masse_objet2 * vitesse_objet2**2
E_p_objet2 = masse_objet2 * 9.8 * hauteur2
print(f"energie totale objet 2 = {E_c_objet2 + E_p_objet2}")

# On a un troisièe objet
masse_objet3 = 0.1
vitesse_objet3 = 90
hauteur3 = 1000
E_c_objet3 = 1/2 * masse_objet3 * vitesse_objet3**2
E_p_objet3 = masse_objet3 * 9.8 * hauteur3
print(f"energie totale objet 3 = {E_c_objet3 + E_p_objet3}")

# Pour éviter les répétitions : je vais tout ranger dans une boite

def calcule_energie_totale(masse,vitesse,hauteur):
  E_c = 1/2 * masse * vitesse ** 2
  E_p = masse * 9.8 * hauteur
  E_tot = E_c + E_p
  return E_tot

masse_objet1 = 12
vitesse_objet1 = 10
hauteur1 = 10
print(calcule_energie_totale(masse_objet1,vitesse_objet1,hauteur1))

masse_objet2 = 100
vitesse_objet2 = 0
hauteur2 = 100
print(calcule_energie_totale(masse_objet2,vitesse_objet2,hauteur2))


masse_objet3 = 0.1
vitesse_objet3 = 90
hauteur3 = 1000
print(calcule_energie_totale(masse_objet3,vitesse_objet3,hauteur3))

"""### Default arguments"""

def calcule_energie_totale(masse,vitesse=0,hauteur=0): # Je fixe des valeurs par défaut Attention : les arguments avec valeurs par déault doivent arriver en "dernier"
  E_c = 1/2 * masse * vitesse ** 2
  E_p = masse * 9.8 * hauteur
  E_tot = E_c + E_p
  return E_tot

# Les arguments ave valeur par défaut (keyword_arguments) peuvent être précisées dans n'importe quel ordre avec un keyword
print(calcule_energie_totale(10,vitesse=5,hauteur=10))
print(calcule_energie_totale(10,hauteur=10,vitesse=5))

# Je suis obligé de préciser les variables qui n'ont pas de valeur par défaut (on les appelle positional arguments)
print(calcule_energie_totale(vitesse=5,hauteur=10))

# Comme leur nom le suggere, les positional argument doivent être précisés dans l'ordre spécifié dans la définition de la fonction

# Bonne utilisation
print(calcule_energie_totale(10,vitesse=5,hauteur=10))

# Mauvaise utilisation : on met l'argument positionnel n'importe ou
print(calcule_energie_totale(vitesse=5,hauteur=10,masse = 10)) # Ca ne bug pas mais ATTENTION CE N'EST PAS RECOMMANDE : une variable positionenlle doit être a la bonne position

hauteur_objet1 = 12
taille_objet1 = 10
E_c_objet1 = 1/2 * hauteur_objet1 * taille_objet1**2
print(E_c_objet1)

"""## Management des exceptions

### Evviter un bug
"""

var1 = 10
var2 = "blablabla"

var1 + var2

var1 = 10
var2 = 2
try:
  print(var1 + var2)
except:
  print(f"l'operation n'a pas marché var1 = {var1}, var2= {var2}")

print("_________________________")
var1 = 10
var2 = "blabla"
try:
  print(var1 + var2)
except:
  print(f"l'operation n'a pas marché var1 = {var1}, var2= {var2}")

"""### Créer un bug"""

raise ValueError("je bug")

# exemple : Je veux faire tourner un algo de Machine Learning, et je sais que cet algo ne prend une liste qu'avec des nombres
# Cet algorightm une fois lancé prend 10j à tourner
# Vous allez le lancer sur une liste

liste = [1,13,32,4,12,"NaN",111]
contient_uniquemen_tnombre = True
for el in liste:
  if type(el) not in [int, float]:
    contient_uniquemen_tnombre = False

if not contient_uniquemen_tnombre:
  raise ValueError(f"Mauvais type de donnee pour element de liste {el}")

"""## Classes

```
class NameOfTheClass():
    def __init__(self, arguments_init): # special method for initializing internal attributes (optional if no internal attributes)
        self.name_attribute1 = ...
        self.name_attribute2 = ...

    def methode1(self, arguments_methode1):
        instructions
        return ... # optional

    def methode2(self, arguments_methode2):
        instructions
        return ... # optional

instance1 = NameOfTheClass(arguments_init1)
instance2 = NameOfTheClass(arguments_init2)
print(instance1.name_attribute1)
print(instance2.name_attribute1)
print(instance1.methode1())

```
"""

class Person():
    def __init__(self,name_person):
        self.espece = "humain"
        self.name = name_person

    def repete_et_affiche_un_mot(self,mot):
        print(mot)

    def presentation(self):
        print(f"Bonjour, je suis un {self.espece}, et mon nom est {self.name}")


person_1 = Person("Antoine")
person_1.presentation()
person_1.name = "Patrick"
person_1.presentation()

person_1.name

class Voiture():
    def __init__(self,modele,puissance_moteur):
        self.modele = modele
        self.puissance_moteur = puissance_moteur
        self.contenu_boite_a_gant = []

    def range_qqchose_boite_a_gant(self,objet):
        # self.contenu_boite_a_gant.append(objet)
        self.contenu_boite_a_gant += [objet]


voiture_antoine = Voiture("DS4",100)
voiture_antoine.range_qqchose_boite_a_gant("chewing-gum")
print("boite a gant antoine",voiture_antoine.contenu_boite_a_gant)


voiture_patrick = Voiture("Picasso",500)
print("boite a gant patrick",voiture_patrick.contenu_boite_a_gant)

"""### Exercice pendu
dans le __init__
- mot
- nombre de vie
- lettres_correctes
- lettres_erreurs

fonction_affichage
- affiche le nombre de lettres
- celles devinees
- celles manquantes

propose_lettre
- prendre en input une lettre
- verifie si elle est dans le mot
- si oui : ok on affiche le mot avec les positions des lettres devinees
- si non : on peut une vie
- si toutes les lettres sont devinees : c'est gagne
- si plus de vies : perdu


"""

class PartiePendu():
    def __init__(self,mot_a_deviner,num):
        self.mot = mot_a_deviner
        self.nombre_de_vies = num
        self.lettres_devinees = []
        self.lettres_erreurs = []

    def fonction_affichage(self):
        # nb_lettres = len(self.mot)
        mot_a_afficher = ""
        for lettre in self.mot:
            if lettre in self.lettres_devinees:
                mot_a_afficher += lettre
            else:
                mot_a_afficher += " _ "
        print(mot_a_afficher)

    def propose_lettre(self,lettre):
        if lettre in self.mot:
            print("oui")
            self.lettres_devinees.append(lettre)
            self.fonction_affichage()
            if len(self.lettres_devinees) == len(set(list(self.mot))):
                print("C'est gagné")
        else:
            self.nombre_de_vies -= 1
            print(f"non, il te reste {self.nombre_de_vies} vies",)

            if self.nombre_de_vies == 0:
                print("C'est perdu")

# while partie1.nombre_de_vies > 0:
#     prochaine_lettre = input("Devinez une lettre")
#     partie1.propose_lettre(prochaine_lettre)


# A compléter ... (faire une variable lié au fait d'avoir gagné qui sorte du while)

partie1 = PartiePendu("antoine",4)
partie1.fonction_affichage()

partie1.propose_lettre("a")

partie1.propose_lettre("n")

partie1.propose_lettre("t")

partie1.propose_lettre("o")

partie1.propose_lettre("i")

partie1.propose_lettre("e")

partie1 = PartiePendu("antoine",4)
partie1.fonction_affichage()

mot = "Antoine"
for el in mot:
  print(type(el))

mot = "Antoine"

"n" in mot

len(set(list(mot)))